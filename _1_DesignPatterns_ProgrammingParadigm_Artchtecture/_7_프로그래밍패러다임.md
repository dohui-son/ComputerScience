# 1\. 프로그래밍 패러다임이란 Programming Paradigm

Programming Paradigm이란 **_개발 방법론_**을 뜻함.  
프로그래밍 패러다임은 프로그래머가 **_컴퓨터 프로그램을 제작할때의 관점_**이라고 할 수 있음.  
선언형과 함수형 프로그래밍, 객체지향 프로그래밍, 절차형 프로그래밍 등이 있고 이런 패러다임들을 혼합해서 사용가능함.

프로그래밍 패러다임은 관점이자 시각이기 때문에 대상의 실체는 변하지 않지만 동일한 대상에 대해서 정의를 다르게 내릴 수도 있음.  
예를 들어 객체지향 프로그래밍은 프로그램을 상호 작용하는 객체들의 집합으로 보는 반면,  
함수형 프로그래밍은 프로그램을 상태 값을 지니지 않는 함수 값들의 연속으로 봄.

# 2\. 프로그래밍 언어와 프로그래밍 패러다임 Programming Language and Programming Paradigm

어떤 언어는 특정 패러다임을 지원하기도 함.  
jdk 1.8 이전의 자바는 객체지향 프로그래밍을 지원하고,  
하스켈은 함수형 프로그래밍을 지원함.  
여러 패러다임을 지원하는 언어는 CPP, PYTHON, JAVASCRIPT 등이 있음.

### 프로그래밍 패러다임의 분류

프로그래밍 패러다임은 크게 선언형/명령형으로 나뉘고,  
선언형은 함수형이라는 하위집합을 가짐.  
명령형은 객체지향/절차지향으로 나눔.

# 3\. 첫번째 패러다임 - 선언형과 함수형 프로그래밍 Declarative & Functional Programming

### 선언형 프로그래밍

선언형 프로그래밍은 '무엇을' 풀어내는가에 집중하는 패러다임.  
(명령형 프로그래밍은 '어떻게' 풀어내는가에 집중.)  
'프로그램은 함수로 이루어진 것이다.'라는 명제를 포함함.

### 함수형 프로그래밍은 선언형 패러다임의 일종

### 함수형 프로그래밍

- 정의 : 함수형 프로그래밍은 작은 순수 함수들을 블록처럼 쌓아 로직을 구현하고, 고차 함수를 통해 재사용성을 높인 프로그래밍 패러다임.
- 자바스크립트는 단순하고 유연한 언어로, 함수가 일급 객체이기 때문에 객체지향 프로그래밍보다는 함수형 프로그래밍 방식이 선호됨.
- 파이썬 / 자바스크립트
- 특징 : 순수함수Pure Function / 비상태 & 불변성 Stateless&Immutability / 선언형 함수 / 1급 객체와 고차함수

**_순수함수_** : 자바스크립트의 reduce()함수는 '배열'을 받아서 루적한 결괏값을 반환하는 순수 함수. 출력이 입력에만 의존하는 것을 의미  
하단의 pure 함수가 전역번수의 영향을 받는다면 순수 함수가 아님.  
(1) 동일한 입력에 대해 항상 같은 값을 반환하는 함수.  
(2) 함수 실행이 프로그램의 실행에 영향을 미치지 않는 함수.  
(3) 함수 내부에서 인자의 값을 변경하거나 프로그램 상태를 변경하는 Side Effect가 없음.

```
const pure = (a, b) => {
  return a + b
}
```

**고차함수와 일급 객체**

- 고차 함수 : 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것.  
  (1) 함수를 인자로써 전달할 수 있다.  
  (2) 함수의 반환 값으로 또 다른 함수를 사용할 수 있다.
- 일급 객체 : 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야함  
  그 특징은 다음과 같다.  
  (1) 변수나 메서드에 함수를 할당 가능  
  (2) 함수 안에 함수를 매개변수로 담을 수 있음  
  (3) 함수가 함수를 반환할 수 있음

# 4\. 두번째 패러다임 - 객체지향 프로그래밍 Object Oriented Programming

- 정의 : 객체등릐 집합으로 프로그램의 상호작용을 표현하며, 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식.
- 설계에 많은 시간이 소요되며, 처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림
- **특징 4가지 : 추상화 / 캡슐화 / 상속성 / 다형성**
- OOP 설계 원칙 5가지 : 단일 책임 원칙 / 개발 폐쇄 원칙 / 리스코프 치환원칙 / 인터페이스 분리 원칙 / 의존관계 역전 원칙

# 5\. 객체지향의 4가지 특징 A.E.I.P

(1) 추상화 Abstraction

- 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것.
- 클래스의 공통적인 특성(변수, 메서드)들을 묶어 표현하는 것.

(2) 캡슐화 Encapsulation

- 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것.
- 데이터와 코드의 형태를 외부로부터 알 수 없게 은닉하고, 데이터의 구조와 역할, 기능을 하나의 캡슐 형태로 만드는 방법. (정보 은닉)
- 쉽게 설명하자면,만약에 호텔에 카드키가 있고 카드키로는 문만 열 수 있는 도어락이 있다면, 손님은 카드키로는 문을 열수만 있고, 비밀번호를 바꾸거나 문이 열리는 원리를 변경할 수 없음.

(3) 상속성 Inheritance

- 상위 클래스의 특성을 하위 클래스가 이어받아 재사용하거나 추가, 확장하는 것.
- 코드의 재사용 측면, 계층적인 관계생성, 유지 보수성 측면에서 중요.
- (부모 클래스에 정의된 변수 및 메서드를 자식 클래스에서 상속받아 사용함.)

(4) 다형성 Polymorphism

- 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것.
- 대표적으로 오버로딩과 오버라이딩이 있음

### 오버로딩

동일 이름을 가진 메서드를 여럿 두는 것. 메서드의 타입, 매개변수 유형, 개수 등으로 여러개 둘 수 있으며,  
 컴파일 중에 발생하는 '정적'다형성임.  
 하나의 클래스 안에서 동일 이름의 메서드를 여러개 정의하는 것.

### 오버라이딩

(일반적으로 메서드 오버라이딩을 지칭) 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것.  
 런타임 중에 발생하는 '동적'다형성임.  
 부모 클래스로부터 상속받은 메서드 내용을 변경하여 사용하는 것으로 매개변수와 리턴 타입이 동일해야함.  
 쉽게 설명하면, 크레이지 아케이드에는 다양한 캐릭터가 있다. 크레이지 아케이드 캐릭터를 부모클래스로 정의하고,  
 배찌, 우니, 마리드를 하위클래스로 생성해보자.  
 부모 클래스에는 캐릭터가 물을 쏘는 스킬 메서드가 존재하고, 뛰기 스킬 메서드가 존재한다.  
 캐릭터마다 물쏘기 강도와 뛰기의 스피드가 다를 것이다.  
 따라서 부모 클래스인 크레이지 아케이드 캐릭터에서 상속받은 메서드(물쏘기, 뛰기)를 각각의 하위 클래스(배찌, 우니, 마리드)에서  
 오버라이딩해서 서로 다른 물쏘기 강도, 뛰기 속도를 갖도록 해야한다.  
 오버라이딩을 안하면, 부모클래스로부터 상속받은 메서드를 하위 클래스가 재정의(오버라이딩)하는 것이 아니라,  
 배찌, 우니, 마리드 각각 하나씩 선언하고 그 각각의 캐릭터들이 쓸 모든 물쏘기, 뛰기를 다 일일이 하드코딩 해야한다.  
 따라서 코드 복잡성도 높아질 뿐만 아니라 코드 일관성이 떨어질 수도 있을 것이다.

# 6\. 객체지향의 5가지 설계원칙 SOLID Rule

Single responsibility principle

Open closed princilple

Liskov substitution principle

Interface segregation principle

Dependency inversion principle

(1) 단일 책임 원칙 SRP, Single Reposibility Principle

- 객체는 오직 하나의 책임만 가져야함.
- 모든 클래스는 각각 단일 책임만 가져야함  
  (예를 들어 A라는 로직이 있다면, 어떤 클래스는 A에 관한 클래스여야하고 이를 수정한다고 해도 A에 관련된 수정이어야함. )
- 사칙연산 함수를 가지고 있는 계산 클래스가 있다고 가정하자. 이 상태의 계산 클래스는 오직 사칙연산 기능만 책임진다. 만일 프로그램 유지보수를 진행해도, 계산 클래스가 수정되어야할 사유는 "사칙연산"함수와 관련된 문제가 있을때만 계산 클래스를 수정해야한다. **_한국어 단어를 영어 단어로 바꿔주는 기능과 관련된 문제가 있어서 계산 클래스를 수정해서는 안된다는 의미다._** 이처럼 단일 책임 원칙은 클래스 목적을 명확히 함으로써 구조가 난잡해지거나 불필요한 수정 사항의 범위가 넓어지는 것을 예방하고 기능을 명확히 분리할 수 있게 함.

(2) 개방-폐쇄 원칙 OCP, Open Closed Principle

- 객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야한다는 원칙.
- 즉, 기존 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야한다는 원칙
- 만약 객체 하나를 수정해야 할때, 그 객체만 수정하는 것이 아닌 그 객체에 의존하는 다른 객체를 모두 고쳐야한다면 좋은 설계로 보기 어려움. 실상황에 빗대자면, 일반적으로 라이브러리를 사용하는 객체의 코드가 변경된다고 해서 라이브러리 코드까지 변경하지는 않음.
- 개방-폐쇄 원칙은 각 객체의 모듈화와 정보 은닉의 올바른 구현 추구를 통해 객체간 의존성 최소화하여 코드 변경에 따른 영향력 감소를 위한 원칙.

(3) 리스코프 치환 원칙 Liskov Substitution Principle

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야함.
- 자식 클래스는 언제나 프로그램 정확성을 깨뜨리지 않으면서 자신의 부모 클래스를 대체할 수 있다는 원칙.
- 해당원칙은 상속의 본질로서 이를 지키지 않으면 부모 클래스의 본래 의미가 변하기에 is-a 관계(EX 상속관계, '사람은 동물이다', '소도 동물이다')가 망가져 다형성이 안 지켜짐.

(4) 인터페이스 분리 원칙 ISP, Interface Segreation Principle

- 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야함.
- 하나의 general한 인터페이스보다 구체화된 여러 개의 인터페이스를 만들어야하는 원칙.
- 아래 이미지<ISP 위반>에서 User1은 op1, User2는 op2, User3는 op3을 각각 사용하는 상황일때, 클라이언트는 자신이 사용하지 않는 op1/2/3에도 의존하고 있음.
- 만약 op2의 소스코드가 변경도면, User1을 컴머파일하여 배포해야하는 문제가 있음.

(5) 의존성 역전 원칙 DIP, Dependency Inversion Principle

- 추상성이 높고 안정적인 고수준의 클래스는 구체적이고 불안정한 저수준 클래스에 의존해서는 안됨.
- 상위 계층은 하위 계층의 변화에 대한 구현으로 부터 독립적이어야함.

# 7. 절차형 프래그래밍이란

- 정의 : 절차형 프로그래밍은 프로시저(루틴, 서비루틴, 메소드, 함수) 콜의 개념에 기반하면서, computationals steps를 중시함. "Step-wise Procedure"
- 순차적 처리를 중요시 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법.
- C, Cobol

**쉽게보는 C Procdures**

- 루틴 : main
- 서브루틴 : main문 밖에서 정의한 코드 블럭 중에 반환 값이 없는 것
- 함수 : main문 밖에서 정의한 코드 블럭 중 반환 값이 있는 것

# 8. 절차형 프래그래밍 장단점

### 장점

- 모듈화와 구조화가 용이함.
- 컴퓨터 처리구조와 유사해 실행 속도가 빠름.
- 계산용으로 적합.

### 단점

- 유지보수의 어려움
- 순서를 바꾸면 결과값을 보장할 수 없음.
- 코드가 길어지면 가독성이 떨어짐.
- OOP보다 상대적으로 대규모 프로젝트에 부적합.

# 9. 패러다임의 혼합

- 비즈니스 로직이나 서비스 특징을 고려하여 패러다임을 정하는 것이 좋음.
- 여러 패러다임을 조합하여 상황과 맥박에 따라 패러다임 간의 장점을 취할 것.

### Reference

도서 : 면접을 위한 CS 전공지식 노트

[https://jongminfire.dev/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80](https://jongminfire.dev/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)  
[https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99](https://namu.wiki/w/%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EC%9B%90%EC%B9%99)  
[https://blog.itcode.dev/posts/2021/08/14/open-closed-principle](https://blog.itcode.dev/posts/2021/08/14/open-closed-principle)  
[https://steady-coding.tistory.com/385](https://steady-coding.tistory.com/385)
